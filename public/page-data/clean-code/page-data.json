{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/clean-code/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<p>항상 내가 짠 코드가 마음에 들지 않는다. 더 좋은 코드를 짜려면 어떻게 해야 할까? 내 마음속에 잠재되어 있던 욕구를 조금이나마 풀어주기 위해 많은 개발자들의 추천 책 ‘클린 코드’를 읽고 챕터마다 간단하게 요약을 해보려고 한다.</p>\n<h2>1장. 깨끗한 코드</h2>\n<ol>\n<li>깨끗한 코드는 제3자 봐도 읽기 쉬워야 한다.</li>\n<li>누구나 수정하기 쉽게 설계되어야 한다.</li>\n<li>개선하려 시도는 할수 있지만 다 원점으로 돌아온다.</li>\n<li>단위 테스트 케이스와 인수 테스트 케이스가 존재한다.</li>\n</ol>\n<p>추상적인 깨끗한 코드에 대한 설명과 여러 네임드 개발자들의 좋은 코드에 대한 생각을 설명해주고 있다. <br />\n여기서 나의 최대의 단점은 테스트 케이스이다. 학부 시절부터 이 부분이 항상 어렵게 다가왔다. 노력해보자.</p>\n<p>(2022-05-13)</p>\n<h2>2장. 의미 있는 이름</h2>\n<ol>\n<li>의도를 분명히 밝혀라. 제 3자가 이름을 볼 때 의도를 파악할 수 있어야한다.</li>\n<li>그릇된 정보를 피하라.</li>\n<li>의미 있게 구분하라.</li>\n<li>발음하기 쉬운 이름을 사용하라.</li>\n<li>검색하기 쉬운 이름을 사용하라.</li>\n<li>인코딩을 피하라.</li>\n<li>자신의 기억력을 자랑하지 마라.</li>\n<li>기발한 이름은 피하라.</li>\n<li>한 개념에 한 단어를 사용하라.</li>\n<li>말장난을 하지 마라.</li>\n<li>해법 영역에서 가져온 이름을 사용하라.</li>\n<li>문제 영역에서 가져온 이름을 사용하라.</li>\n<li>의미 있는 맥락을 추가하라.</li>\n<li>불필요한 맥락을 없애라.</li>\n</ol>\n<p>한마디로 요약하자면, 의미 있지만 알기 쉽고 관련 분야에 가장 근접한 이름을 선택 하는 것이 중요하다. 언제든 다시 코드를 볼 때 무슨 의도를 갖고 작성했는데 단번에 이해할 수 있어야 한다.<br />\n그 동안 프로그래밍을 하면서 나름 위에 명시되어 있는 방법대로 이름을 선정 하려고 노력하고 있었다. 다만, 가끔 반복문을 돌릴때나 내가 봤을 때 별로 중요하다고 생각하지 않았던 부분에 임시 변수를 사용하고 수정을 하지 않았던 기억이 난다. (테스트 하다 정상작동 할때) <br />\n그 부분을 고치려고 노력해야겠다.</p>\n<p>(2022-05-17)</p>\n<h2>3장. 함수</h2>\n<ol>\n<li>함수는 한 가지 일을 ‘잘’ 해야 한다.</li>\n<li>함수 인수(argument, parameter) 는 최대한 적게 사용해라.</li>\n<li>include 방법으로 중복을 없애라.</li>\n<li>구조적 프로그래밍 원칙 - 함수는 return 문이 하나여야 하고 반복문에서 break나 continue를 사용해선 안 되면 goto는 ‘절대로’ 안 된다.</li>\n</ol>\n<p>(2022-05-18, 2022-05-19)</p>\n<h2>4장. 주석</h2>\n<ol>\n<li>나쁜코드를 주석으로 보완하려 하지 말고 좋은 코드를 짜라.</li>\n<li>Todo 주석은 주기적으로 없애라.</li>\n<li>코드는 변경되거나 이동될 수 있지만 주석은 같이 수정되진 않는 경우가 많아서 오해할 여지를 충분히 준다.</li>\n<li>주석을 달기 전에 항상 필요한 주석인지 다시 한번 생각해보자.</li>\n</ol>\n<p>대학에선 과제 코드에 주석을 잘 달았는 지에 대한 점수 배당이 있어서 의무적으로 주석으로 설명을 해야 했다. 그래서 그렇게 하는게 맞다고 배웠다.\n좋은 코드란 뭘까? 개인에 따라 다르지만 이 책은 주석에 대한 내 생각을 정리할 수 있게 도와준다.</p>\n<p>(2022-05-21)</p>\n<h2>5장. 형식 맞추기</h2>\n<ol>\n<li>적절한 행의 길이를 유지하라.</li>\n<li>코드는 신문기사 처럼 작성하라.</li>\n<li>개념은 빈행으로 분리하라.</li>\n<li>세로 밀집도, 수직거리, 변수 선언</li>\n<li>종족 함수나 개념적 유사성이 있는 함수는 가까운 곳에 배치하라.</li>\n<li>들여쓰기에 신경써라.</li>\n<li>팀 규칙을 정해 IDE에 규칙을 추가하고 프로젝트를 진행해라</li>\n</ol>\n<p>(2022-05-21)</p>\n<h2>6장. 객체와 자료구조</h2>\n<ol>\n<li>객체와 자료 구조</li>\n<li>디미터의 법칙 (Law of Demeter): 객체의 한 객체가 알아야 하는 다른 객체를 최소한으로 유지하라는 의미로 Principle of least knowledge(최소 지식 원칙)라고도 불린다.</li>\n<li>기차 충돌(Train Wreck)을 피해라.</li>\n<li>자료 전달 객채: 공개 변수만 있고 함수가 없는 클래스.</li>\n</ol>\n<p>(2022-05-23)</p>\n<h2>7장. 오류 처리</h2>\n<ol>\n<li>오류 코드보다 예외를 사용하라.</li>\n<li>미확인 예외를 사용하라.</li>\n<li>감싸기 클래스</li>\n<li>null을 반환하지 마라.</li>\n</ol>\n<p>(2022-05-24)</p>\n<h2>8장. 경계</h2>\n<ol>\n<li>학습 테스트: 외부 코드를 호출하기 전에 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익힌다.</li>\n<li>경계에 위치한 코드는 깔끔히 분리한다.</li>\n</ol>\n<p>(2022-05-25)</p>\n<h2>9장. 테스트</h2>\n<ol>\n<li>테스트는 가독성, 가독성 그리고 가독성.</li>\n<li>테스트당 개념 하나.</li>\n<li>F.I.R.S.T</li>\n</ol>\n<ul>\n<li>Fast: 테스트는 빨라야 한다.</li>\n<li>Independent: 각 테스트는 서로 의존하면 안된다.</li>\n<li>Repeatable: 테스트는 어떤 환경에서도 반복 가능해야 한다.</li>\n<li>Self-Validation: 테스트는 bool 값으로 결과를 내야 한다.</li>\n<li>Timely: 테스트는 적시에 작성해야 한다.</li>\n</ul>\n<p>테스트 테스트 테스트.. 중요하단걸 알고 있지만 빠른시간 안에 결과를 내려고 하다보면 많이 생략하게 된다. 테스트를 작성하면 어느 부분에서 문제가 생기는지 빠르게 알수 있으니까 오류 처리 시간이 줄어 들텐데..</p>\n<p>(2022-05-26)</p>\n<h2>10장. 클래스</h2>\n<ol>\n<li>클래스는 작아야 한다.</li>\n<li>시스템의 결합도를 낮추면 유연성과 재상용성이 높아진다.</li>\n</ol>\n<p>클래스의 크기에 대해 깊이 생각해 본적이 없었다. 좋은 챕터였다.</p>\n<p>(2022-05-28)</p>\n<h2>11장. 시스템</h2>\n<ol>\n<li>시스템 제작과 시스템 사용을 분리하라.</li>\n<li>테스트 주도 시스템 아키텍처 구축.</li>\n</ol>\n<p>성급한 결정은 불충분한 지식으로 내린 결정이다. 가능한 마지막 순간까지 최한 정보를 모아 내는 결정이 최선의 결정이다.</p>\n<ul>\n<li>자바 스프링 구조 공부</li>\n</ul>\n<p>(2022-06-03)</p>\n<h2>12장. 창발성</h2>\n<ol>\n<li>모든 테스트를 실행하라.</li>\n<li>리팩토링, 중복을 없애라.</li>\n<li>나중에 읽을 사람을 고려해 표현하라.</li>\n<li>클래스와 메서드 수를 최소로 줄여라.</li>\n</ol>\n<p>(2022-06-06)</p>\n<h2>13장. 동시성</h2>\n<ol>\n<li>동시성 코드는 다른 코드와 분리하라.</li>\n<li>종료 코드를 개발 초기부터 고민하고 동작하게 구현하라.</li>\n<li>스레드 코드 테스트하기.</li>\n</ol>\n<ul>\n<li>말이 안되는 실패는 잠정적인 스레드 문제로 취급하라.</li>\n<li>다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자.</li>\n<li>다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라.</li>\n<li>다중 스레드를 쓰ㄴ 코드 부분을 상황에 맞게 조율할 수 있게 작성하라.</li>\n<li>프로세서 수보다 많은 스레드를 돌려보라.</li>\n<li>다른 플랫폼에서 돌려보라.</li>\n<li>강제로 실패를 일으키게 해보라.</li>\n</ul>\n<p>(2022-06-07)</p>\n<h2>14장. 점진적인 개선</h2>\n<p>TDD(Test Driven Development)\n테스트 클레스를 만들어 계속해서 테스트를 실행 하면서 실패하지 않는 선에서 코드를 개선해 나간다.</p>\n<p>(2022-06-09)</p>\n<h2>15장. JUnit 들여다보기</h2>\n<p>코드를 리팩터링 하다 보면 원래 했던 변경을 되돌리는 경우가 흔하다. 세상에 개선이 불필요한 모듈은 없다. 코드를 처음보다 조금 더 깨끗하게 만드는 책임은 우리 모두에게 있다.</p>\n<p>(2022-06-11)</p>\n<h2>16장. SerialDate 리팩터링</h2>\n<ul>\n<li>오래된 주석을 고치고 개선했다.</li>\n<li>enum을 모두 독자적인 소스 파일로 옮겼다.</li>\n<li>정적 변수와 정적 메서드를 새 클래스로 옮겼다.</li>\n<li>일부 추상 메서드를 끌어올렸다.</li>\n<li>메서드 중복을 없애고 새 메서드를 생성했다.</li>\n</ul>\n<p>(2022-06-13)</p>\n<h2>17장. 냄새와 휴리스틱</h2>\n<p>전체적으로 복습하는 섹션이다. 뭘 요약할 것도 없이 이 섹션은 전체적으로 복습을 해야 한다.</p>\n<p>(2022-07-05)</p>\n<h2>18장. 동시성 II.</h2>\n<p>다중 스레드를 이용한 프로그램은 결함이 생기기 마련이다. 대책을 마련하고 최대한 많은 테스트를 해봐라.</p>\n<p>(2022-07-13)</p>","frontmatter":{"title":"Clean Code","summary":"클린코드 리마인드용 개인 요약","date":"2022.05.13.","categories":["Book Review","Clean Code"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAAUABQDASIAAhEBAxEB/8QAGgABAAMAAwAAAAAAAAAAAAAAAAEDBAUGCf/EABUBAQEAAAAAAAAAAAAAAAAAAAID/9oADAMBAAIQAxAAAAH3RrsxRfaEqjLBN8mKD//EABwQAAMBAAIDAAAAAAAAAAAAAAIDBAEAEQUSFP/aAAgBAQABBQKzv72tqDkxMKervPJh6STzbmocgDoOVZcWGLD/xAAaEQACAgMAAAAAAAAAAAAAAAACERASQbHh/9oACAEDAQE/ARaVbbxyBj//xAAfEQABAwMFAAAAAAAAAAAAAAABABESAkGBEyExUfD/2gAIAQIBAT8BraQOpAsL7cnHay6rAkPXQX//xAAnEAACAgEDAgUFAAAAAAAAAAABAgMREgAEIUFRBRMUIjEjYXGBwf/aAAgBAQAGPwLYKskgPkb8iJSwWSvSDJ6pbiDHDJlPvJW6I01F+tWuQHY8LzXzWXPxeoWlOUhjXM4423U42cfxZrvrw+TG0TbeJZNXILehxW+mRB+xrnSbeTdbncvFkGn3ZR9xIWdn+o0MccXtywXBBSKo5qzER1XUEhvJY9wi9gJQmfFdcRrkv+iB/NKgulFCzzr/xAAcEAEBAQADAQEBAAAAAAAAAAABESEAMUFhUXH/2gAIAQEAAT8hTSpLv7IwSpQ8BMVh2iRjC5gz9OXQEOc8s5dPzK74M+NKoglMRKIaJeexrRNwjpQ82StUoYmK+On8eezdojaEik9pnV3iOLr4XUmZ5OPWrC0V7crz/9oADAMBAAIAAwAAABDoMAD/xAAdEQEAAgICAwAAAAAAAAAAAAABESEAYTFBEFFx/9oACAEDAQE/EFICFel6EEs+ClNY8tRfF1q7rd4kGFJbhj14/8QAHREBAAICAgMAAAAAAAAAAAAAAREhADFBUZGx0f/aAAgBAgEBPxAzCiIgMEJGEtIVkKKcNHQXUOrqr3XdcQiUGjYPLvAQUaPR8PBn/8QAGhABAQEBAQEBAAAAAAAAAAAAAREhADFBUf/aAAgBAQABPxDbj7a8QkAgdBJFuz0bZUVAUYKSe1F8gGFuFo1KOMtS0lEvKAEIptlOs6hWObOJ4A7qFMoCfoCNEpyUp9FQcU35yi0VUqAMB+UYZgAua2iqQHCWehdh87//2Q=="},"images":{"fallback":{"src":"/static/4f0bc582015aad0e262d69b775d1ac7d/d23cf/clean-code.jpg","srcSet":"/static/4f0bc582015aad0e262d69b775d1ac7d/c911d/clean-code.jpg 125w,\n/static/4f0bc582015aad0e262d69b775d1ac7d/f11c1/clean-code.jpg 250w,\n/static/4f0bc582015aad0e262d69b775d1ac7d/d23cf/clean-code.jpg 500w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[{"srcSet":"/static/4f0bc582015aad0e262d69b775d1ac7d/e6b33/clean-code.webp 125w,\n/static/4f0bc582015aad0e262d69b775d1ac7d/84816/clean-code.webp 250w,\n/static/4f0bc582015aad0e262d69b775d1ac7d/adf24/clean-code.webp 500w","type":"image/webp","sizes":"(min-width: 500px) 500px, 100vw"}]},"width":500,"height":488.00000000000006}}},"publicURL":"https://kyong-dev.github.io"}}}]}},"pageContext":{"slug":"/clean-code/"}},
    "staticQueryHashes": []}